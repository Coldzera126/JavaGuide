# 你应该知道的Java面试题

## 基础题目

1. Java线程的状态

   ```
   1.初始（NEW）:新创建了一个线程对象，但还没有调用start()方法。
   2.运行（RUNNABLE)：Java线程中将就绪（ready)和运行中（running)两种状态笼统的称为“运行”。线程对象创建后，其他线程（比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程再获得CPU时间片后变成运行中状态（running）。
   3.阻塞（BLOCKED):表示线程阻塞于锁。
   4.等待（WAITING）:进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
   5.超时等待（TIMED_WAITING）:该状态不同于WAITING，他可以在指定的时间后自行返回。
   6.终止（TERMINATED）:表示该线程已经执行完毕。
   
   转载链接：https://blog.csdn.net/pange1991/article/details/53860651
   ```

2. 进程和线程的区别，进程间如何通讯，线程间如何通讯

   ```yaml
   1.定义：
   	* 进程：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位；————提高CPU的利用率
   	* 线程：是进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源； ————提高程序的效率
   
   2.关系
   	* 一个线程可以创建和撤销另一个线程
   	* 同一个进程中的多个线程之间可以并发执行
   	* 线程也可以称作轻量级的进程
   	* 进程在执行过程中拥有独立的内存单元，而线程则可以与同一个进程中的其他线程共享这段内存，但拥有自己的栈空间、拥有独立的执行序列
   	
   3.区别
   	* 进程拥有独立的地址空间，一个进程崩溃后在保护模式下不会对其他进程产生影响；但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉（？怎么理解），所以多进程的程序要比多线程的程序健壮
   	* 进程切换时，耗费资源较大，效率要差一些；线程切换的开销较小（不利用资源的管理和保护）。所以对于一些要求同时进行并且又要共享某些变量的并发操作，就只能用线程，不能用进程
   	* 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制
   	* 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配
   	* 一个程序至少有一个进程，一个进程至少有一个线程
   	* 线程的划分尺度小于进程，使得多线程程序的并发性高
   	* 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率
   
   4.通信方式
   	（1）进程通讯
   		* 管道
   			a) 无名管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘				 关系的进程间使用。进程的亲缘关系通常是指父子进程关系
   			b) 高级管道（popen）：将另外一个程序当做一个新的进程在当前程序进程中启动，则它算是当				 前程序的子线程，这种方式我们称为高级管道方式
   			c) 有名管道（named pipe）：有名管道也是半双工的通信方式，克服了管道没有名字的限制，			   同时是它允许无亲缘关系进程间的通讯
   		* 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程		  	间通信外，进程还可以发生信号给进程本身;linux除了支持Unix早期信号语义函数signal外，			 还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实			 现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）
   		* 信号量（Semaphore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问，它常作为			  一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以
   		    以及同一进程内不同线程之间的同步手段
   		* 消息队列（Message queue）：消息队列是由消息的链表，存放在内核中并由消息队列标识符标				识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓存区大小受限等缺点
   		* 共享内存（Shared memory）：共享内存就是映射一段能够被其它进程所访问的内存，这段共享内				存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其它进程间通			信方式运行效率低而专门设计的。它往往与其它通信机制，如信号量，配合使用，来实现进程间的			   同步和通信
   		* 套接字（Socket）：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机			器间的进程通信。最初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix				系统上：Linux和System V的变种都支持套接字
   	（2）线程通讯
   		* 共享内存。同上面所述
   		* 管道。首先建立管道流，并将管道流中的输入输出对象进行链接；将管道流加入到生产对象（线程）			中；通过管道流引出输入输出流，并在线程中对这些流进行操作；注：管道流的read的方法是一种阻			塞方法
   		* 调用公共接口，还有如Scala语言中的Actor机制等等
   		* 锁机制。包括互斥锁、条件变量、读写锁
   			a) 互斥锁提供了以排他方式防止数据结构被并发修改的方法
   			b) 读写锁运行多个线程同时读共享数据，而对写操作是互斥的
   			c) 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁			   的保护下进行的。条件变量始终与互斥锁一起使用
   		* 信号量机制（Semaphore）：包括无名线程信号量和命名线程信号量
   		* 信号机制（Signal）：类似进程间的信号处理，线程间的通信目的主要是用于线程同步，所以线程		    没有像进程通信中的用于数据交换的通信机制
   		
   	
   ```

3. HashMap的数据结构是什么？如何实现的。和HashTable,ConcurrentHashMap的区别

   ```
   a) HashMap的数据结构：数组+链表，数组中元素是个链表，存储Key的hashcode碰撞的元素
   b) HashMap的实现：
   	* 链表结构： hashcode相同的元素头尾相连组成一个单链，并把最开始的那个节点存储在数组中，访问的		时候，先通过hash(key)找到数组下标，再迭代单链找到equals()的value，然后返回
   	* table的resize(): resize的时候，如果当前数组的占用率达到负载因子0.75，则会触发一次				resize(),增长量为原来容量(table.length)的一倍，newCap = oldCap<<1，然后把老数组的		 数据迁移到新的数组
   c) HashMap和HashTable的区别
   	* HashTable是线程安全的，HashTable是所有暴露操作都加锁（synchronized），这种情况下性能较	  差，容易引起活跃性问题
   	* HashTable跟java.util.Collections#synchronizedMap很接近；HashMap允许key和value为	  null,HashTable不允许key和value为null
   d) HashMap和ConcurrentHashMap区别
   	* ConcurrentHashMap也是线程安全的，区别是它采用的是CAS的方式来处理并发操作
   	* 如果单链比较长久坍缩成一个红黑树，log(n)的时间复杂度
   	* 1.8之前的ConcurrentHashMap是采用分段（Segment）的方式，加锁时直接在Segment上加锁，缩小		了加锁范围，提高了性能；1.8之后的ConcurrentHashMap是重写的，加锁范围进一步缩小，采用CAS将	  加锁范围缩小到单个数组元素，性能上较之前有提高
   ```

4. Cookie和Session的区别

   ```
   HTTP协议与状态保持：HTTP是一个无状态协议
   
   1.实现状态保持的方案：
   1）修改HTTP协议，使得它支持状态保持（难做到去修改一个协议，协议无状态的设计是有目的的）
   2）Cookies:通过客户端来保持状态信息
   	* Cookies是服务器发给客户端的特殊信息
   	* Cookies是以文本的方式保存在客户端，每次客户端的请求都会带上Cookies
   3）Session:通过服务器来保持状态信息
   	* Session是服务器和客户端之间的一系列的交互动作
   	* 服务器为每个客户端开辟内存空间，从而保持状态信息
   	* 由于需要客户端也要持有一个标识（ID），因此也要求服务器端和客户端传输该标识
   	* 标识（ID）可以借助Cookies机制或者其他的途径来保存
   
   2.Cookie机制
   1）Cookie的基本特点
   	* Cookie保存在客户端
   	* 只能保存字符串对象，不能保存对象类型
   	* 需要客户端浏览器的支持：客户端可以不支持，浏览器用户可能会禁用Cookie
   2) 采用Cookie需要解决的问题
   	* Cookie的创建： 通常是在服务端创建的（当然也可以通过javascript来创建），服务器通过在HTTP的	   响应头加上特殊的指示，那么浏览器在读取这个指示后就会生成相应的Cookie了
   	* Cookie存放的内容： 业务信息（key,value），过期时间，域和路径
   	* 浏览器是如何通过Cookie和服务器通信： 通过请求与响应，cookie在服务器和客户端之间传递，每次请求和响应都把cookie信息加载到响应头中（依靠cookie的key传递）
   
   3.Cookie编程（略）
   
   4.Session机制
   每次客户端发送请求，服务端都检查是否含有sessionId:
   	如果有，则根据sessionId检索出session并处理；如果没有，则创建一个session，并绑定一个不重复的sessionId
   1) 基本特点
   	* 状态信息保存在服务器端	——这意味着安全性更高
   	* 通过类似与HashTable的数据结构来保存
   	* 能支持任何类型的对象（session中可含有多个对象）
   2）保存会话id的技术
   	* Cookie： 这是默认的方式，在客户端与服务端传递JSessionId
   	——缺点：客户端可能禁用Cookie
   	* 表单隐藏字段： 在被传递回客户端之前，在form里面加入一个hidden域，设置JSessionId
   	—— <input type=hidden name=jsessionid value="3948E432F90932A549D34532EE2394" />
   	* URL重写：直接在URL后附加上session id的信息，HttpServletResponse对象中，提供了如下的方		法：encodeURL(url);//url为相对路径
   	
   5.Session编程（略）
   
   6.两种状态跟踪机制的比较
   	Cookie				 	  |	Session
   	保持在客户端				  |	保存在服务端
   	只能保持字符串对象	  		| 支持各种类型对象
   	通过过期时间值区分Cookie类型  | 需要sessionId为维护与客户端的通信
   	会话Cookie ———— 负数 Cookie（默认）
   	普通Cookie ———— 正数 表单隐藏字段
   	不支持Cookie ———— 0 URL重写
   	
   	应用领域：web交易需要保存状态的时候，都可以使用，比如在分布式场景下可以利用分布式session技术等
   
   ```

5. 索引有什么用？如何建索引？

   ```
   索引的作用：适当的使用索引可以提高数据检索速度
   建立索引：
   	* 索引（普通）：CREATE INDEX 索引名 ON 表名（列名）
   	* 唯一索引 ：CREATE unique INDEX 索引名 ON 表名（列名）
   	* 组合索引 ：CREATE INDEX 索引名 ON 表名（列名1，列名2）
   	* 反向键索引：CREATE INDEX 索引名 ON 表名（列名） reverse
   	   # 对索引列的值进行反向，即预先对列值进行比特位的反向，如 1000,10001,10011,10111,1100经		过反向后的值将是0001,1001,1101,0011。显然经过位反向处理的有序数据变得比较随机了，这样所		得到的索引树就比较对称，从而提高表的查询性能
   	   # 应用场合，优缺点....
   
   索引的副作用：
   1）索引是有大量数据的时候才建立的，没有大量数据反而会浪费时间，因为索引是使用二叉树建立
   2）当一个系统查询比较频繁，而新建，修改等操作比较少时，可以创建索引，这样查询的速度会比以前快很多，同时也带来弊端，就是新建或修改等操作时，比没有索引或者没有建立覆盖索引时的要慢
   3）索引并不是越多越好，太多索引会占用很多的索引表空间，甚至比存储一条记录更多
   
   ——对于需要频繁新增记录的表，最好不要创建索引，没有索引的表，执行insert、append都很快，有了索引以后，会多一个维护索引的操作，一些大表可能insert速度非常慢
   
   对千万级MySQL数据库建立索引的事项及提高性能的手段
   一、注意事项：
   1）应当考虑表空间和磁盘空间是否足够。索引也是一种数据，在建立索引的时候势必也会占用大量表空间。因此在对一大表建立索引的时候首先应当考虑的是空间容量问题
   2）在对建立索引的时候要对表进行加锁，因此应当注意操作在业务空闲的时候进行
   二、性能调整方面：
   1）考虑因素：磁盘I/O。物理上，应当尽量把索引与数据分散到不同的磁盘上（不考虑阵列的情况）。逻辑上，数据表空间与索引表空间分开。这是在建索引时应当遵守的基本守则
   2）在建立索引的时候要对表进行全表扫描工作，因此，应当考虑调大初始化参数db_file_multiblock_read_count的值。一般设置为32或更大
   3）
   ```

6. ArrayList是如何实现的，ArrayList和LinkedList的区别？ArrayList如何实现扩容。

7. equals方法实现

8. 面向对象

9. 线程状态，BOLCKED和WAITING有什么区别

10. JVM如何加载字节码文件

11. JVM GC,GC算法

12. 什么情况下会出现Full GC，什么情况会出现永GC

13. JVM内存模型

14. Java运行时数据区

15. 事务的实现原理

16. JDK1.8的主要更新内容（新增）

##技术深度##

1. 有没有看过JDK源码，看过的类实现原理是什么。
2. HTTP协议
3. TCP协议
4. 一致性Hash算法
5. JVM如何加载字节码文件
6. 类加载器如何卸载字节码
7. IO和NIO的区别，NIO优点
8. Java线程池的实现原理，keepAliveTime等参数的作用
9. HTTP连接池实现原理
10. 数据库连接池实现原理
11. 数据库的实现原理

##技术框架##

1. 看过哪些开源框架的源码
2. 为什么要用Redis，Redis有哪些优缺点？Redis如何实现扩容？
3. Netty是如何使用线程池的，为什么这么使用
4. 为什么要使用Spring，Spring的优缺点有哪些
5. Spring的IOC容器初始化流程
6. Spring的IOC容器实现原理，为什么可以通过ByName和ByType找到Bean
7. Spring AOP实现原理
8. 消息中间件是如何实现的，技术难点有哪些

##系统架构##

1. 如何搭建一个高可用系统
2. 哪些设计模式可以增加系统的可扩展性
3. 介绍设计模式，如模板模式，命令模式，策略模式，适配器模式，桥接模式，装饰模式，观察者模式，状态模式，访问者模式。
4. 抽象能力，怎么提高研发效率
5. 什么是高内聚低耦合，请举例子如何实现
6. 什么情况用接口，什么情况用消息
7. 如果AB两个系统相互依赖，如何解除依赖
8. 如何写一篇设计文档，目录是什么
9. 什么场景应该拆分系统，什么场景应该合并系统
10. 系统和模块的区别，分别在什么场景下使用

##分布式系统##

1. 分布式事务，两阶段提交
2. 如何实现分布式锁
3. 如何实现分布式Session
4. 如何保证消息的一致性
5. 负载均衡
6. 正向代理（客户端代理）和反向代理（服务端代理）
7. CDN实现原理
8. 怎么提升系统的QPS和吞吐量

##实战能力##
##软能力##



